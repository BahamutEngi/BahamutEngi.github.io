[{"title":"数组/链表","date":"2021-12-22T06:17:43.000Z","path":"2021/12/22/数组-链表/","text":"数组/链表主要算法： 双指针 前缀和 差分数组 1. 前缀和 适用于快速、频繁计算一个索引区间内的元素之和1.1 一维数组的前缀和LeetCode_303 区域和检索-数组不可变实现函数sumRange(i, j)，用于求解给定数组下标范围$[i,j]$元素的和。由于题目所述sumRange会调用至多$10^4$次，如果单纯使用循环O(n)，速度会很慢。因此，考虑使用前缀和，可以把函数sumRange的时间复杂度降低为O(1)。前缀和数组preNums定义为：$$ preNums[i] = preNums[i-1] + nums[i-1]$$即有，第$i$个元素表示数组nums中前$i$个元素之和，因此需要给其赋初值0，且$$ size(preNums) = size(nums) + 1$$在此基础上，$[i,j]$的元素之和为前$j+1$个元素和减去前$i$个元素和，即有：$$ ans = preNums[j+1] - preNums[i]$$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class NumArray&#123;private: vector&lt;int&gt; preNums &#123;0&#125;; // 前缀和数组public: NumArray(vector&lt;int&gt;&amp; nums) &#123; for(int i=1; i&lt;= nums.size(); ++i) &#123; preNums[i] = preNums[i-1] + nums[i]; &#125; &#125; int sumRange(int left, int right) &#123; return preNums[right + 1] - preNums[left]; &#125;&#125;;``` ## 1.2 二维数组的前缀和[LeetCode_304 二维区域和检索-矩阵不可变](https://leetcode-cn.com/problems/range-sum-query-2d-immutable/) 303的二维矩阵版本，基于前缀和的算法如图 ![思路](数组-链表/fig1.png) 前缀和数组$preNums[i,j]$定义为，从左上角$(0,0)$开始，前$i$行，前$j$列的元素之和。 ```C++class NumMatrix &#123;private: vector&lt;vector&lt;int&gt;&gt; preNum;public: NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; // 初始化 int m = matrix.size(); int n = matrix[0].size(); preNum.resize(m + 1, vector&lt;int&gt;(n + 1, 0)); for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; preNum[i][j] = preNum[i - 1][j] + preNum[i][j - 1] + matrix[i - 1][j - 1] - preNum[i - 1][j - 1]; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return preNum[row2 + 1][col2 + 1] - preNum[row1][col2 + 1] - preNum[row2 + 1][col1] + preNum[row1][col1]; &#125;&#125;;``` 注意，使用vector的resize函数，可以指定vector的大小并赋值。## 1.3 练习[LeetCode_560 和为k的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/) 给定数组nums，寻找元素之和等于k的子数组个数。 基于前缀和的思想，可以写出如下算法：### 算法一：枚举所有子数组，根据前缀和求出他们的元素之和$O(n^2)$，C++超时延续1.1节中preNums的定义，则从下标$i$到下标$j$的子数组nums[i, j]的元素之和sum(i, j)为： $$sum(i, j)=preNums(j+1)-preNums(i)$$```C++int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; preNums &#123;0&#125;; int ans = 0, n = nums.size(); for(int i = 1; i &lt;= n; ++i) &#123; preNums[i] = preNums[i - 1] + nums[i - 1]; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; if(preNums[j + 1] - preNums[i] == k) &#123; ans++; &#125; &#125; &#125; return ans;&#125; 算法二：前缀和+哈希表（难想！）算法一中，判断条件为等价于：$$对于所有的preNums[i],$$$$寻找满足preNums[j + 1]-preNums[i] == k(j\\geq i)的j的个数$$可以转化为：$$对于所有的preNums[j+1],$$$$寻找满足preNums[i] == preNums[j+1]-k(i\\leq j)的i的个数$$对于此类在前面找满足关系的问题，可以用hash表进行优化，即：$$记录下每个前缀和出现的次数，$$$$对于某个前缀和a，如果之前计算过a-k的次数，则加上$$ 12345678910111213141516int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0, pre_i = 0; int n = nums.size(); unordered_map&lt;int, int&gt; preNums; preNums[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; pre_i += nums[i - 1]; int pre_j = pre_i - k; if(preNums.find(pre_j) != preNums.end()) &#123; ans += preNums.[pre_j]; &#125; int add = preNums.find(pre_i) != preNums.end() ? preNums[pre_i] : 0; preNums[pre_i] = add + 1; &#125; return ans;&#125; 注意，代码中的preNums[0] = 1;，根据我们定义的前缀和，其表示前$i$个元素的和，因此当$i=0$时，前缀和为0，出现了1次。 1.4 1.3中利用hash表空间换时间的相关题目题目1：LeetCode_1 两数之和给定数组nums和整数target，找到nums中和为target的两个元素的下标。若采用暴力枚举，则两层for循环，时间复杂度为$O(n^2)$。而采用hash表可以减少一层循环，时间复杂度为$O(n)$，即$$记录下第i个元素nums[i]对应的下标，$$$$若target - nums[i]在hash表中，则找到，直接返回$$ 123456789101112131415161718vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; dict; vector&lt;int&gt; ans; for(int i = 0; i &lt; nums.size(); ++i) &#123; int temp = target - nums[i]; if(dict.find(temp) != dict.end()) &#123; // 找到了 ans.push_back(dict.at(temp)); ans.push_back(i); break; &#125; else &#123; // 没找到，则加入map dict[nums[i]] = i; &#125; &#125; return ans;&#125; 题目2：LeetCode_454 四数相加-ii给定4个长度为n的数组num1-num4，计算满足$$nums1[i]+nums2[j]+nums3[k]+nums4[l]=0$$的元组$(i,j,k,l)$的个数。若暴力枚举，则四层for循环，时间复杂度为$O(n^4)$。可以将四个数组分成两两一组，则上述条件转化为：$$nums1[i]+nums2[j] = -(nums3[k]+nums4[l])$$则可以利用hash表将时间复杂度降低至$O(n^2)$：$$先计算nums1[i]+nums2[j]所有取值出现的个数存入hash表，$$$$然后遍历nums3[k]+nums4[l]的所有取值，$$$$若-(nums3[k]+nums4[l])存在于hash表中，则ans加上hash表的value$$ 123456789101112131415161718int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int, int&gt; dict; int n = nums1.size(); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; int sum = nums1[i] + nums2[j]; dict[sum] = dict.find(sum) != dict.end() ? dict[sum] + 1 : 1; &#125; &#125; int ans = 0; for(int k = 0; k &lt; n; ++k) &#123; for(int l = 0; l &lt; n; ++l) &#123; int sum = -(nums3[k] + nums4[l]); ans += dict.find(sum) != dict.end() ? dict[sum] : 0; &#125; &#125; return ans;&#125; 题目3：LeetCode_1248 统计优美子数组该题目的思路和1.3中的LeetCode_560 和为k的子数组几乎一样，只是将前缀和换成奇数个数，只需要改一下计算条件，由前缀和的pre_i += nums[i-1]变成带判断的pre_i += nums[i-1] % 2 == 0 ? 0 : 1。 123456789101112131415int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0, n = nums.size(), pre_i = 0; unordered_map&lt;int, int&gt; dict; dict[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; pre_i += nums[i-1] % 2 == 0 ? 0 : 1; int pre_j = pre_i - k; if(dict.find(pre_j) != dict.end()) &#123; ans += dict[pre_j]; &#125; int add = dict.find(pre_i) != dict.end() ? dict[pre_i] : 0; dict[pre_i] = add + 1; &#125; return ans;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"},{"name":"数组/链表","slug":"Leetcode/数组-链表","permalink":"http://example.com/categories/Leetcode/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"}],"tags":[]},{"title":"Hello World","date":"2021-12-21T05:34:21.356Z","path":"2021/12/21/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]