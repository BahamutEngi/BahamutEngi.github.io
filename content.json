[{"title":"力扣-数组/链表-双指针","date":"2021-12-23T04:59:37.000Z","path":"2021/12/23/力扣-数组-链表-双指针/","text":"","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"},{"name":"数组/链表","slug":"Leetcode/数组-链表","permalink":"http://example.com/categories/Leetcode/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"力扣-数组/链表-差分数组","date":"2021-12-23T04:59:27.000Z","path":"2021/12/23/力扣-数组-链表-差分数组/","text":"差分数组 适用于频繁对原始数组的某个区间的元素进行加减运算。 1. 差分数组原理1.1 定义对于给定数组$nums[i],(i=0,…,n-1)$，定义差分数组$diff[i],(i=0,…,n-1)$如下： diff[i]=\\left\\{\\begin{matrix} nums[0], & i=0\\\\ nums[i]-nums[i-1], & i\\geq 1 \\end{matrix}\\right.1.2 性质/用途 区间加减操作对区间$[i,j]$内的所有元素加$a$，若进行循环，时间复杂度为$O(n)$，利用差分数组，可以将时间复杂度降低到$O(1)$： \\left\\{\\begin{matrix} diff[i]+=a\\\\ diff[j+1]-=a,(若j=n-1，则不进行该操作) \\end{matrix}\\right. 反求原数组可以进行递推，即有： \\left\\{\\begin{matrix} nums[0]=diff[0]\\\\ nums[i]=nums[i-1]+diff[i] \\end{matrix}\\right. 查询数组某个元素根据差分数组的定义，有： nums[i]=\\sum_{j=0}^idiff[j] 计算前缀和，进而可以计算区间和 \\begin{aligned} preNums[i]=&\\sum_{j=0}^{i-1}nums[j]\\\\ =&\\sum_{j=0}^{i-1}\\sum_{k=0}^{j}diff[k]\\\\ =&\\sum_{j=0}^{i-1}(i-j)diff[j] \\end{aligned}sumRange(i, j)=preNums[j+1]-preNums[i]2 相关题目1LeetCode_1109 航班预定统计本质上是一个数组区间相加问题，给定一个长度为$n$的全0数组$ans$，以及一堆三元组$(i,j,a)$，表示区间$[i,j]$的所有元素加$a$，之后返回原始数组。123456789101112131415vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) &#123; vector&lt;int&gt; ans(n, 0); vector&lt;int&gt; diff(n, 0); for(auto booking : bookings) &#123; diff[booking[0] - 1] += booking[2]; if(booking[1] - 1 != n - 1) &#123; diff[booking[1]] -= booking[2]; &#125; &#125; ans[0] = diff[0]; for(int i = 1; i &lt; n; ++i) &#123; ans[i] = ans[i - 1] + diff[i]; &#125; return ans;&#125; 3. 相关题目2LeetCode_1094 拼车本质上仍是数组区间相加问题，给定全零数组，以及一堆三元组$(a, i, j)$，由于乘客先下后上，应该将区间$[i,j)$内的元素加$a$。最后，所有元素都小于capacity时，返回true。123456789101112131415161718192021bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) &#123; vector&lt;int&gt; diff(1001, 0); int max_loc = 0; for(auto trip : trips) &#123; int loc_start = trip[1]; int loc_end = trip[2]; max_loc = max(max_loc, max(loc_start, loc_end)); diff[loc_start] += trip[0]; diff[loc_end] -= trip[0]; &#125; int res = 0; bool ans = true; for(int i = 0; i &lt;= max_loc; ++i) &#123; res += diff[i]; if(res &gt; capacity) &#123; ans = false; break; &#125; &#125; return ans;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"},{"name":"数组/链表","slug":"Leetcode/数组-链表","permalink":"http://example.com/categories/Leetcode/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"差分数组","slug":"差分数组","permalink":"http://example.com/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"}]},{"title":"力扣-数组/链表-前缀和","date":"2021-12-23T04:57:39.000Z","path":"2021/12/23/力扣-数组-链表-前缀和/","text":"前缀和 适用于原数组不被修改的情况下，快速、频繁计算一个索引区间内的元素之和。1. 一维数组的前缀和LeetCode_303 区域和检索-数组不可变实现函数sumRange(i, j)，用于求解给定数组下标范围$[i,j]$元素的和。由于题目所述sumRange会调用至多$10^4$次，如果单纯使用循环O(n)，速度会很慢。因此，考虑使用前缀和，可以把函数sumRange的时间复杂度降低为O(1)。前缀和数组preNums定义为： preNums[i] = preNums[i-1] + nums[i-1]即有，第$i$个元素表示数组nums中前$i$个元素之和，因此需要给其赋初值0，且size(preNums) = size(nums) + 1在此基础上，$[i,j]$的元素之和为前$j+1$个元素和减去前$i$个元素和，即有：ans = preNums[j+1] - preNums[i]12345678910111213class NumArray&#123;private: vector&lt;int&gt; preNums &#123;0&#125;; // 前缀和数组public: NumArray(vector&lt;int&gt;&amp; nums) &#123; for(int i=1; i&lt;= nums.size(); ++i) &#123; preNums[i] = preNums[i-1] + nums[i]; &#125; &#125; int sumRange(int left, int right) &#123; return preNums[right + 1] - preNums[left]; &#125;&#125;; 2. 二维数组的前缀和LeetCode_304 二维区域和检索-矩阵不可变303的二维矩阵版本，基于前缀和的算法如图前缀和数组$preNums[i,j]$定义为，从左上角$(0,0)$开始，前$i$行，前$j$列的元素之和。 123456789101112131415161718192021class NumMatrix &#123;private: vector&lt;vector&lt;int&gt;&gt; preNum;public: NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; // 初始化 int m = matrix.size(); int n = matrix[0].size(); preNum.resize(m + 1, vector&lt;int&gt;(n + 1, 0)); for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; preNum[i][j] = preNum[i - 1][j] + preNum[i][j - 1] + matrix[i - 1][j - 1] - preNum[i - 1][j - 1]; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return preNum[row2 + 1][col2 + 1] - preNum[row1][col2 + 1] - preNum[row2 + 1][col1] + preNum[row1][col1]; &#125;&#125;; 注意，使用vector的resize函数，可以指定vector的大小并赋值。3. 练习LeetCode_560 和为k的子数组给定数组nums，寻找元素之和等于k的子数组个数。基于前缀和的思想，可以写出如下算法：算法一：枚举所有子数组，根据前缀和求出他们的元素之和$O(n^2)$，C++超时延续1.1节中preNums的定义，则从下标$i$到下标$j$的子数组nums[i, j]的元素之和sum(i, j)为： sum(i, j)=preNums(j+1)-preNums(i)123456789101112131415int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; preNums &#123;0&#125;; int ans = 0, n = nums.size(); for(int i = 1; i &lt;= n; ++i) &#123; preNums[i] = preNums[i - 1] + nums[i - 1]; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; if(preNums[j + 1] - preNums[i] == k) &#123; ans++; &#125; &#125; &#125; return ans;&#125; 算法二：前缀和+哈希表（难想！）算法一中，判断条件为等价于： 对于所有的preNums[i],寻找满足preNums[j + 1]-preNums[i] == k(j\\geq i)的j的个数可以转化为：对于所有的preNums[j+1],寻找满足preNums[i] == preNums[j+1]-k(i\\leq j)的i的个数对于此类在前面找满足关系的问题，可以用hash表进行优化，即： 记录下每个前缀和出现的次数，对于某个前缀和a，如果之前计算过a-k的次数，则加上12345678910111213141516int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0, pre_i = 0; int n = nums.size(); unordered_map&lt;int, int&gt; preNums; preNums[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; pre_i += nums[i - 1]; int pre_j = pre_i - k; if(preNums.find(pre_j) != preNums.end()) &#123; ans += preNums.[pre_j]; &#125; int add = preNums.find(pre_i) != preNums.end() ? preNums[pre_i] : 0; preNums[pre_i] = add + 1; &#125; return ans;&#125; 注意，代码中的preNums[0] = 1;，根据我们定义的前缀和，其表示前$i$个元素的和，因此当$i=0$时，前缀和为0，出现了1次。 4 利用hash表空间换时间的相关题目题目1：LeetCode_1 两数之和给定数组nums和整数target，找到nums中和为target的两个元素的下标。若采用暴力枚举，则两层for循环，时间复杂度为$O(n^2)$。而采用hash表可以减少一层循环，时间复杂度为$O(n)$，即 记录下第i个元素nums[i]对应的下标，若target - nums[i]在hash表中，则找到，直接返回123456789101112131415161718vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; dict; vector&lt;int&gt; ans; for(int i = 0; i &lt; nums.size(); ++i) &#123; int temp = target - nums[i]; if(dict.find(temp) != dict.end()) &#123; // 找到了 ans.push_back(dict.at(temp)); ans.push_back(i); break; &#125; else &#123; // 没找到，则加入map dict[nums[i]] = i; &#125; &#125; return ans;&#125; 题目2：LeetCode_454 四数相加-ii给定4个长度为n的数组num1-num4，计算满足nums1[i]+nums2[j]+nums3[k]+nums4[l]=0的元组$(i,j,k,l)$的个数。若暴力枚举，则四层for循环，时间复杂度为$O(n^4)$。可以将四个数组分成两两一组，则上述条件转化为： nums1[i]+nums2[j] = -(nums3[k]+nums4[l])则可以利用hash表将时间复杂度降低至$O(n^2)$： 先计算nums1[i]+nums2[j]所有取值出现的个数存入hash表，然后遍历nums3[k]+nums4[l]的所有取值，若-(nums3[k]+nums4[l])存在于hash表中，则ans加上hash表的value123456789101112131415161718int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int, int&gt; dict; int n = nums1.size(); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; int sum = nums1[i] + nums2[j]; dict[sum] = dict.find(sum) != dict.end() ? dict[sum] + 1 : 1; &#125; &#125; int ans = 0; for(int k = 0; k &lt; n; ++k) &#123; for(int l = 0; l &lt; n; ++l) &#123; int sum = -(nums3[k] + nums4[l]); ans += dict.find(sum) != dict.end() ? dict[sum] : 0; &#125; &#125; return ans;&#125; 题目3：LeetCode_1248 统计优美子数组该题目的思路和1.3中的LeetCode_560 和为k的子数组几乎一样，只是将前缀和换成奇数个数，只需要改一下计算条件，由前缀和的pre_i += nums[i-1]变成带判断的pre_i += nums[i-1] % 2 == 0 ? 0 : 1。123456789101112131415int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0, n = nums.size(), pre_i = 0; unordered_map&lt;int, int&gt; dict; dict[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; pre_i += nums[i-1] % 2 == 0 ? 0 : 1; int pre_j = pre_i - k; if(dict.find(pre_j) != dict.end()) &#123; ans += dict[pre_j]; &#125; int add = dict.find(pre_i) != dict.end() ? dict[pre_i] : 0; dict[pre_i] = add + 1; &#125; return ans;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"},{"name":"数组/链表","slug":"Leetcode/数组-链表","permalink":"http://example.com/categories/Leetcode/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]}]