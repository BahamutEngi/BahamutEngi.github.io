[{"title":"力扣-数组/链表-双指针","date":"2021-12-23T04:59:37.000Z","path":"2021/12/23/力扣-数组-链表-双指针/","text":"双指针 快慢指针（链表问题） 左右指针（数组问题）1. 快慢指针 初始化在链表的head节点，前进时快指针fast在前，慢指针slow在后。 fast跑的快，slow跑得慢，需要注意边界条件。1.1 判断链表是否有环LeetCode_141 环形链表令快指针速度为2，慢指针速度为1 \\left\\{\\begin{matrix} 链表有环, & 快指针追上慢指针\\\\ 链表无环, & 快指针到达null \\end{matrix}\\right.123456789101112131415bool hasCycle(ListNode *head) &#123; ListNode *fast, *slow; if(head == nullptr) &#123; return false; &#125; fast = slow = head; while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) &#123; return true; &#125; &#125; return false;&#125; 1.2 若有环，求链表中环的起点LeetCode_142 环形链表II设slow指针速度为$v$，则fast指针速度为$2v$，设二者走了$n$步后相遇在交点，则有： \\left\\{\\begin{matrix} vn=L1+L2 \\\\ 2vn=L1+L2+L3+L2\\\\ \\end{matrix}\\right.二者相减，并带入$vn=L1+L2$，得L1=L3因此，思路为：在1.1的基础上，快慢指针相遇后，令其中一个指向head，然后二者以速度1移动，相遇时即为环入口。1234567891011121314151617181920ListNode *detectCycle(ListNode *head) &#123; if(head == nullptr) &#123; return nullptr; &#125; ListNode* fast, *slow; fast = slow = head; while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if(fast == slow) &#123; fast = head; while(fast != slow) &#123; slow = slow-&gt;next; fast = fast-&gt;next; &#125; return fast; &#125; &#125; return nullptr;&#125; 1.3 寻找链表的中点LeetCode_876 链表的中间节点利用快慢指针，可以少遍历一次链表求链表长度。快指针速度为2，慢指针速度为1，当快指针走到表尾时慢指针即为中间节点。注意停止条件： 当链表长度为奇数时，快指针走到表尾元素，此时fast-&gt;next == nullptr,slow指向唯一中间节点； 当链表长度为偶数时，快指针走到表尾元素的下一个，即空，此时fast == nullptr, slow指向右边的中间节点。 123456789ListNode* middleNode(ListNode* head) &#123; ListNode* fast, *slow; fast = slow = head; while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; return slow;&#125; 1.4 寻找链表倒数第n个元素LeetCode_19 删除链表的倒数第n个节点利用快慢指针，可以少遍历一次链表求链表长度。先让快指针走n步，然后快指针和慢指针都以速度1前进，当fast-&gt;next == nullptr时，slow指向待删除节点前一个节点。注意待删除节点是第一个节点的情况，这时fast走n步后直接变成nullptr，需要单独讨论！1234567891011121314151617ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode* fast, *slow; fast = slow = head; for(int i=0; i&lt;n; ++i) &#123; fast = fast-&gt;next; &#125; if(fast == nullptr) &#123; // 说明待删除节点是第一个 return head-&gt;next; &#125; while(fast-&gt;next != nullptr) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; slow-&gt;next = slow-&gt;next-&gt;next; return head;&#125; 2. 左右指针2.1 两数之和LeetCode_167 两数之和II数组有序，则可以用类似二分查找的思想，sum偏大了就--right，sum偏小了就++left。12345678910111213141516vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int left = 0, right = numbers.size() - 1; while(left &lt; right) &#123; int sum = numbers[left] + numbers[right]; if(sum == target) &#123; return vector&lt;int&gt; &#123;left+1, right+1&#125;; &#125; else if(sum &gt; target) &#123; --right; &#125; else &#123; ++left; &#125; &#125; return vector&lt;int&gt; &#123;-1, -1&#125;;&#125; 2.2 反转数组LeetCode_344 反转字符串要求使用$O(1)$的额外空间，则只能用双指针进行原地操作.12345678910void reverseString(vector&lt;char&gt;&amp; s) &#123; int left = 0, right = s.size() - 1; while(left &lt; right) &#123; char temp = s[left]; s[left] = s[right]; s[right] = temp; ++left; --right; &#125;&#125; 滑动窗口和二分查找算法单独开两章写","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"},{"name":"数组/链表","slug":"Leetcode/数组-链表","permalink":"http://example.com/categories/Leetcode/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"双指针","slug":"双指针","permalink":"http://example.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"力扣-数组/链表-差分数组","date":"2021-12-23T04:59:27.000Z","path":"2021/12/23/力扣-数组-链表-差分数组/","text":"差分数组 适用于频繁对原始数组的某个区间的元素进行加减运算。 1. 差分数组原理1.1 定义对于给定数组$nums[i],(i=0,…,n-1)$，定义差分数组$diff[i],(i=0,…,n-1)$如下： diff[i]=\\left\\{\\begin{matrix} nums[0], & i=0\\\\ nums[i]-nums[i-1], & i\\geq 1 \\end{matrix}\\right.1.2 性质/用途 区间加减操作对区间$[i,j]$内的所有元素加$a$，若进行循环，时间复杂度为$O(n)$，利用差分数组，可以将时间复杂度降低到$O(1)$： \\left\\{\\begin{matrix} diff[i]+=a\\\\ diff[j+1]-=a,(若j=n-1，则不进行该操作) \\end{matrix}\\right. 反求原数组可以进行递推，即有： \\left\\{\\begin{matrix} nums[0]=diff[0]\\\\ nums[i]=nums[i-1]+diff[i] \\end{matrix}\\right. 查询数组某个元素根据差分数组的定义，有： nums[i]=\\sum_{j=0}^idiff[j] 计算前缀和，进而可以计算区间和 \\begin{aligned} preNums[i]=&\\sum_{j=0}^{i-1}nums[j]\\\\ =&\\sum_{j=0}^{i-1}\\sum_{k=0}^{j}diff[k]\\\\ =&\\sum_{j=0}^{i-1}(i-j)diff[j] \\end{aligned}sumRange(i, j)=preNums[j+1]-preNums[i]2 相关题目1LeetCode_1109 航班预定统计本质上是一个数组区间相加问题，给定一个长度为$n$的全0数组$ans$，以及一堆三元组$(i,j,a)$，表示区间$[i,j]$的所有元素加$a$，之后返回原始数组。123456789101112131415vector&lt;int&gt; corpFlightBookings(vector&lt;vector&lt;int&gt;&gt;&amp; bookings, int n) &#123; vector&lt;int&gt; ans(n, 0); vector&lt;int&gt; diff(n, 0); for(auto booking : bookings) &#123; diff[booking[0] - 1] += booking[2]; if(booking[1] - 1 != n - 1) &#123; diff[booking[1]] -= booking[2]; &#125; &#125; ans[0] = diff[0]; for(int i = 1; i &lt; n; ++i) &#123; ans[i] = ans[i - 1] + diff[i]; &#125; return ans;&#125; 3. 相关题目2LeetCode_1094 拼车本质上仍是数组区间相加问题，给定全零数组，以及一堆三元组$(a, i, j)$，由于乘客先下后上，应该将区间$[i,j)$内的元素加$a$。最后，所有元素都小于capacity时，返回true。123456789101112131415161718192021bool carPooling(vector&lt;vector&lt;int&gt;&gt;&amp; trips, int capacity) &#123; vector&lt;int&gt; diff(1001, 0); int max_loc = 0; for(auto trip : trips) &#123; int loc_start = trip[1]; int loc_end = trip[2]; max_loc = max(max_loc, max(loc_start, loc_end)); diff[loc_start] += trip[0]; diff[loc_end] -= trip[0]; &#125; int res = 0; bool ans = true; for(int i = 0; i &lt;= max_loc; ++i) &#123; res += diff[i]; if(res &gt; capacity) &#123; ans = false; break; &#125; &#125; return ans;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"},{"name":"数组/链表","slug":"Leetcode/数组-链表","permalink":"http://example.com/categories/Leetcode/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"差分数组","slug":"差分数组","permalink":"http://example.com/tags/%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84/"}]},{"title":"力扣-数组/链表-前缀和","date":"2021-12-23T04:57:39.000Z","path":"2021/12/23/力扣-数组-链表-前缀和/","text":"前缀和 适用于原数组不被修改的情况下，快速、频繁计算一个索引区间内的元素之和。1. 一维数组的前缀和LeetCode_303 区域和检索-数组不可变实现函数sumRange(i, j)，用于求解给定数组下标范围$[i,j]$元素的和。由于题目所述sumRange会调用至多$10^4$次，如果单纯使用循环O(n)，速度会很慢。因此，考虑使用前缀和，可以把函数sumRange的时间复杂度降低为O(1)。前缀和数组preNums定义为： preNums[i] = preNums[i-1] + nums[i-1]即有，第$i$个元素表示数组nums中前$i$个元素之和，因此需要给其赋初值0，且size(preNums) = size(nums) + 1在此基础上，$[i,j]$的元素之和为前$j+1$个元素和减去前$i$个元素和，即有：ans = preNums[j+1] - preNums[i]12345678910111213class NumArray&#123;private: vector&lt;int&gt; preNums &#123;0&#125;; // 前缀和数组public: NumArray(vector&lt;int&gt;&amp; nums) &#123; for(int i=1; i&lt;= nums.size(); ++i) &#123; preNums[i] = preNums[i-1] + nums[i]; &#125; &#125; int sumRange(int left, int right) &#123; return preNums[right + 1] - preNums[left]; &#125;&#125;; 2. 二维数组的前缀和LeetCode_304 二维区域和检索-矩阵不可变303的二维矩阵版本，基于前缀和的算法如图前缀和数组$preNums[i,j]$定义为，从左上角$(0,0)$开始，前$i$行，前$j$列的元素之和。 123456789101112131415161718192021class NumMatrix &#123;private: vector&lt;vector&lt;int&gt;&gt; preNum;public: NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; // 初始化 int m = matrix.size(); int n = matrix[0].size(); preNum.resize(m + 1, vector&lt;int&gt;(n + 1, 0)); for(int i = 1; i &lt;= m; ++i) &#123; for(int j = 1; j &lt;= n; ++j) &#123; preNum[i][j] = preNum[i - 1][j] + preNum[i][j - 1] + matrix[i - 1][j - 1] - preNum[i - 1][j - 1]; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return preNum[row2 + 1][col2 + 1] - preNum[row1][col2 + 1] - preNum[row2 + 1][col1] + preNum[row1][col1]; &#125;&#125;; 注意，使用vector的resize函数，可以指定vector的大小并赋值。3. 练习LeetCode_560 和为k的子数组给定数组nums，寻找元素之和等于k的子数组个数。基于前缀和的思想，可以写出如下算法：算法一：枚举所有子数组，根据前缀和求出他们的元素之和$O(n^2)$，C++超时延续1.1节中preNums的定义，则从下标$i$到下标$j$的子数组nums[i, j]的元素之和sum(i, j)为： sum(i, j)=preNums(j+1)-preNums(i)123456789101112131415int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; preNums &#123;0&#125;; int ans = 0, n = nums.size(); for(int i = 1; i &lt;= n; ++i) &#123; preNums[i] = preNums[i - 1] + nums[i - 1]; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; if(preNums[j + 1] - preNums[i] == k) &#123; ans++; &#125; &#125; &#125; return ans;&#125; 算法二：前缀和+哈希表（难想！）算法一中，判断条件为等价于： 对于所有的preNums[i],寻找满足preNums[j + 1]-preNums[i] == k(j\\geq i)的j的个数可以转化为：对于所有的preNums[j+1],寻找满足preNums[i] == preNums[j+1]-k(i\\leq j)的i的个数对于此类在前面找满足关系的问题，可以用hash表进行优化，即： 记录下每个前缀和出现的次数，对于某个前缀和a，如果之前计算过a-k的次数，则加上12345678910111213141516int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0, pre_i = 0; int n = nums.size(); unordered_map&lt;int, int&gt; preNums; preNums[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; pre_i += nums[i - 1]; int pre_j = pre_i - k; if(preNums.find(pre_j) != preNums.end()) &#123; ans += preNums.[pre_j]; &#125; int add = preNums.find(pre_i) != preNums.end() ? preNums[pre_i] : 0; preNums[pre_i] = add + 1; &#125; return ans;&#125; 注意，代码中的preNums[0] = 1;，根据我们定义的前缀和，其表示前$i$个元素的和，因此当$i=0$时，前缀和为0，出现了1次。 4 利用hash表空间换时间的相关题目题目1：LeetCode_1 两数之和给定数组nums和整数target，找到nums中和为target的两个元素的下标。若采用暴力枚举，则两层for循环，时间复杂度为$O(n^2)$。而采用hash表可以减少一层循环，时间复杂度为$O(n)$，即 记录下第i个元素nums[i]对应的下标，若target - nums[i]在hash表中，则找到，直接返回123456789101112131415161718vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; dict; vector&lt;int&gt; ans; for(int i = 0; i &lt; nums.size(); ++i) &#123; int temp = target - nums[i]; if(dict.find(temp) != dict.end()) &#123; // 找到了 ans.push_back(dict.at(temp)); ans.push_back(i); break; &#125; else &#123; // 没找到，则加入map dict[nums[i]] = i; &#125; &#125; return ans;&#125; 题目2：LeetCode_454 四数相加-ii给定4个长度为n的数组num1-num4，计算满足nums1[i]+nums2[j]+nums3[k]+nums4[l]=0的元组$(i,j,k,l)$的个数。若暴力枚举，则四层for循环，时间复杂度为$O(n^4)$。可以将四个数组分成两两一组，则上述条件转化为： nums1[i]+nums2[j] = -(nums3[k]+nums4[l])则可以利用hash表将时间复杂度降低至$O(n^2)$： 先计算nums1[i]+nums2[j]所有取值出现的个数存入hash表，然后遍历nums3[k]+nums4[l]的所有取值，若-(nums3[k]+nums4[l])存在于hash表中，则ans加上hash表的value123456789101112131415161718int fourSumCount(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, vector&lt;int&gt;&amp; nums3, vector&lt;int&gt;&amp; nums4) &#123; unordered_map&lt;int, int&gt; dict; int n = nums1.size(); for(int i = 0; i &lt; n; ++i) &#123; for(int j = 0; j &lt; n; ++j) &#123; int sum = nums1[i] + nums2[j]; dict[sum] = dict.find(sum) != dict.end() ? dict[sum] + 1 : 1; &#125; &#125; int ans = 0; for(int k = 0; k &lt; n; ++k) &#123; for(int l = 0; l &lt; n; ++l) &#123; int sum = -(nums3[k] + nums4[l]); ans += dict.find(sum) != dict.end() ? dict[sum] : 0; &#125; &#125; return ans;&#125; 题目3：LeetCode_1248 统计优美子数组该题目的思路和1.3中的LeetCode_560 和为k的子数组几乎一样，只是将前缀和换成奇数个数，只需要改一下计算条件，由前缀和的pre_i += nums[i-1]变成带判断的pre_i += nums[i-1] % 2 == 0 ? 0 : 1。123456789101112131415int numberOfSubarrays(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0, n = nums.size(), pre_i = 0; unordered_map&lt;int, int&gt; dict; dict[0] = 1; for(int i = 1; i &lt;= n; ++i) &#123; pre_i += nums[i-1] % 2 == 0 ? 0 : 1; int pre_j = pre_i - k; if(dict.find(pre_j) != dict.end()) &#123; ans += dict[pre_j]; &#125; int add = dict.find(pre_i) != dict.end() ? dict[pre_i] : 0; dict[pre_i] = add + 1; &#125; return ans;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://example.com/categories/Leetcode/"},{"name":"数组/链表","slug":"Leetcode/数组-链表","permalink":"http://example.com/categories/Leetcode/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"}],"tags":[{"name":"前缀和","slug":"前缀和","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"}]}]